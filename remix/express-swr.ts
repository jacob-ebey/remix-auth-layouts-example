// polyfill globals
import "@remix-run/express";

import type * as express from "express";
import type {
  AppLoadContext,
  ServerBuild,
  ServerPlatform,
} from "@remix-run/server-runtime";
import { createRequestHandler as createRemixRequestHandler } from "@remix-run/server-runtime";
import type { ServerRoute } from "@remix-run/server-runtime/routes";
import { createRoutes } from "@remix-run/server-runtime/routes";
import { matchServerRoutes } from "@remix-run/server-runtime/routeMatching";

import {
  Headers as NodeHeaders,
  Response as NodeResponse,
  formatServerError,
} from "@remix-run/node";
import { createRemixRequest } from "@remix-run/express/server";
import parseCacheControlHeader from "parse-cache-control";

declare module "@remix-run/server-runtime/routeModules" {
  interface ServerRouteModule {
    cacheKey?: (request: Request) => Promise<string | null> | string | null;
  }
}

declare module "parse-cache-control" {
  interface Header {
    "s-maxage"?: string;
    "stale-while-revalidate"?: boolean;
  }
}

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by Express middleware like `req.session`.
 */
export interface GetLoadContextFunction {
  (req: express.Request, res: express.Response): AppLoadContext;
}

export type RequestHandler = ReturnType<typeof createSwrRequestHandler>;

type CachedResponse = {
  body: string;
  headers: [string, string][];
  staleAt: number;
  status: number;
  statusText: string;
};

export type StaleWhileRevalidateStore = {
  del(key: string): Promise<void>;
  get(key: string): Promise<string | null>;
  set(key: string, value: string, maxAge: number): Promise<void>;
};

type CacheStatus = "HIT" | "STALE" | "MISS" | "BYPASS" | "REVALIDATED";

function getMaxAge(cacheControlHeader: string | null) {
  let cacheControl =
    cacheControlHeader && parseCacheControlHeader(cacheControlHeader);

  let maxAge: number | undefined = undefined;
  if (
    cacheControl &&
    !cacheControl["no-store"] &&
    cacheControl["stale-while-revalidate"]
  ) {
    let smaxage = cacheControl["s-maxage"];
    if (typeof smaxage !== "undefined") {
      maxAge =
        typeof smaxage === "string" ? Number.parseInt(smaxage, 10) : smaxage;
    } else if (typeof cacheControl["max-age"] !== "undefined") {
      maxAge = cacheControl["max-age"];
    }
  }
  return maxAge;
}

async function cacheKeyFromRequest(
  request: Request,
  version: string,
  routes: ServerRoute[]
) {
  if (request.method.toLowerCase() !== "get") {
    return null;
  }

  let url = new URL(request.url);
  let matchedRoutes = matchServerRoutes(routes, url.pathname) || [];

  if (url.searchParams.has("_data")) {
    matchedRoutes = matchedRoutes.filter(
      (match) => match.route.id === url.searchParams.get("_data")
    );
  }

  return [
    `version: ${version}`,
    `url: ${request.url}`,
    ...(
      await Promise.all(
        matchedRoutes.map((match) => {
          if (match.route.module.cacheKey) {
            return match.route.module.cacheKey(request.clone());
          }
          return null;
        })
      )
    ).filter((segment) => segment != null),
  ].join(" | ");
}

/**
 * Returns a request handler for Express that serves the response using Remix.
 */
export function createSwrRequestHandler({
  build,
  getLoadContext,
  mode = process.env.NODE_ENV,
  store,
}: {
  build: ServerBuild;
  getLoadContext?: GetLoadContextFunction;
  mode?: string;
  store: StaleWhileRevalidateStore;
}) {
  let platform: ServerPlatform = { formatServerError };
  let handleRequest = createRemixRequestHandler(build, platform, mode);
  let routes = createRoutes(build.routes);

  return async (
    req: express.Request,
    res: express.Response,
    next: express.NextFunction
  ) => {
    try {
      let request = createRemixRequest(req);
      let loadContext =
        typeof getLoadContext === "function"
          ? getLoadContext(req, res)
          : undefined;

      let skipCache = request.headers.get("Pragma")?.includes("no-cache");
      let cacheKey = await cacheKeyFromRequest(
        request.clone() as unknown as Request,
        build.assets.version,
        routes
      );
      let cachedJSON =
        !skipCache && cacheKey ? await store.get(cacheKey) : null;
      let cachedResponse: CachedResponse | null = cachedJSON
        ? JSON.parse(cachedJSON)
        : null;
      let stale = cachedResponse
        ? new Date().getTime() > cachedResponse.staleAt
        : false;
      let cacheStatus: CacheStatus = cacheKey
        ? skipCache
          ? "REVALIDATED"
          : cachedResponse
          ? stale
            ? "STALE"
            : "HIT"
          : "MISS"
        : "BYPASS";

      async function revalidate() {
        let revalidatedResponse = (await handleRequest(
          request.clone() as unknown as Request,
          loadContext
        )) as unknown as NodeResponse;

        let maxAge = getMaxAge(
          revalidatedResponse.headers.get("Cache-Control")
        );

        if (typeof maxAge !== "number") {
          cacheStatus = "BYPASS";
        } else if (cacheKey) {
          let staleAtDate = new Date();
          staleAtDate.setSeconds(staleAtDate.getSeconds() + maxAge);
          let staleAt = staleAtDate.getTime();

          let responseToCache: CachedResponse = {
            body: await revalidatedResponse.clone().text(),
            headers: Array.from(revalidatedResponse.headers.entries()),
            staleAt,
            status: revalidatedResponse.status,
            statusText: revalidatedResponse.statusText,
          };

          await store.set(cacheKey, JSON.stringify(responseToCache), maxAge);
        }

        return revalidatedResponse.clone();
      }

      let response: NodeResponse;

      if (cachedResponse) {
        let headers = new NodeHeaders(cachedResponse.headers);
        response = new NodeResponse(cachedResponse.body, {
          headers,
          status: cachedResponse.status,
          statusText: cachedResponse.statusText,
        });

        revalidate().catch((error) => console.error(error));
      } else {
        response = await revalidate();
      }

      if (cacheKey) {
        response.headers.set("x-cache-key", cacheKey);
      }
      response.headers.set("x-cache-status", cacheStatus);

      sendRemixResponse(res, response);
    } catch (error) {
      // Express doesn't support async functions, so we have to pass along the
      // error manually using next().
      next(error);
    }
  };
}

function sendRemixResponse(
  res: express.Response,
  response: NodeResponse
): void {
  res.status(response.status);

  for (let [key, values] of Object.entries(response.headers.raw())) {
    for (const value of values) {
      res.append(key, value);
    }
  }

  if (Buffer.isBuffer(response.body)) {
    res.end(response.body);
  } else if (response.body?.pipe) {
    response.body.pipe(res);
  } else {
    res.end();
  }
}
